"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs_1 = require("mz/fs");
const eventToPromise = require("event-to-promise");
const child_process_1 = require("child_process");
const types_1 = require("./types");
const tsconfig = {
    version: '2.4.2',
    compilerOptions: {
        lib: ['es2017', 'esnext'],
        target: 'es2017',
        module: 'commonjs',
        moduleResolution: 'node',
        emitDecoratorMetadata: true,
        checkJs: false,
        allowJs: false,
        experimentalDecorators: true,
        downlevelIteration: true,
        sourceMap: true,
        declaration: true,
        strict: true,
        outDir: '.',
    },
    include: [
        'src/*.ts',
    ],
    exclude: [
        'node_modules',
    ],
};
const spawn = (command, args, options) => eventToPromise(child_process_1.spawn(command, args, options), 'exit');
class TSOutput {
    constructor(genPath) {
        this.genPath = genPath;
        this.npm = (...args) => spawn('npm', args, { cwd: genPath, stdio: 'inherit' });
        this.tsc = (...args) => spawn('tsc', args, { cwd: this.genPath, stdio: 'inherit' });
    }
    static async create(genPath) {
        const st = await fs_1.stat(genPath);
        if (!st.isDirectory()) {
            throw new Error(`output dir: ${genPath} is not a directory`);
        }
        return new this(genPath);
    }
    async write(name, version, { code, pkg: basePackage }, role) {
        try {
            await fs_1.mkdir(path.join(this.genPath, 'src'));
        }
        catch (err) {
            if (err.code !== 'EEXIST') {
                throw err;
            }
        }
        await Promise.all(Object.entries(code).map(([n, c]) => fs_1.writeFile(path.join(this.genPath, 'src', n), c)));
        await fs_1.writeFile(path.join(this.genPath, 'tsconfig.json'), JSON.stringify(tsconfig));
        const main = role === types_1.Role.ALL ? 'interfaces' : role;
        const pkgName = role === types_1.Role.ALL ? name : `${name}-${role}`;
        const pkg = Object.assign({}, basePackage, { main: `${main}.js`, description: 'Generated by launch', repository: 'undefined', types: `${main}.d.ts`, name: pkgName, version });
        await fs_1.writeFile(path.join(this.genPath, 'package.json'), JSON.stringify(pkg));
    }
    async compile() {
        await this.npm('i');
        await this.tsc();
    }
    async publish(tag) {
        if (tag) {
            await this.npm('publish', '--tag', tag);
        }
        else {
            await this.npm('publish');
        }
    }
}
exports.TSOutput = TSOutput;
//# sourceMappingURL=output.js.map